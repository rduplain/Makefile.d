#!/usr/bin/env bash
# Generate SHA256 of a git ref, defaulting to current git HEAD.
#
# See README caveats of GitHub's tarball SHA256.

# Exit immediately if a command error or non-zero return occurs.
set -e

# The name of this executable program.
PROG="$( basename "${BASH_SOURCE[0]}" )"

given() {
    # Check that the given commands exist.

    local error=''

    for command in "$@"; do
        if ! which "$command" > /dev/null; then
            echo "$PROG requires '$command' command, but cannot find it." >&2
            error=true
        fi
    done

    if [ -n "$error" ]; then
        return 3
    fi
}

dirty() {
    # Check if git repository is dirty, return zero if dirty.
    #
    # Here, dirty means one or both of:
    #
    # * the git index is not empty (compared to HEAD)
    # * the working tree has changes (compared to HEAD)

    if git diff-index --quiet --cached HEAD && git diff-files --quiet; then
        return 1
    fi

    return 0

}

warn-if-dirty-head() {
    # Warn to stderr if target ref is HEAD and working tree is dirty.

    if [ $# -ne 1 ]; then
        echo "usage: warn-if-dirty REF" >&2
        return 2
    fi

    local target_ref=$1
    shift

    if [ "$target_ref" = "HEAD" ] && dirty; then
        echo 'warning: git repository is dirty.'                            >&2
        echo                                                                >&2
        echo '`git archive` will not include any uncommitted changes.'      >&2
        echo                                                                >&2
        echo                                                                >&2
    fi
}

generate-sha256() {
    # Generate SHA256 checksum of git archive, for given ref.

    if [ $# -ne 1 ]; then
        echo "usage: generate-sha256 REF" >&2
        return 2
    fi

    local ref="$1"
    shift

    local url=$(git remote get-url origin)

    if [ -z "$url" ] || [ "${url//github/}" = "${url}" ]; then
        echo "Remote 'origin' is not GitHub: $url" >&2
        return 1
    fi

    local github_user=$(echo ${url} | awk -F '[/:]' '{ print $(NF-1) }')
    local github_project_git=$(echo ${url} | awk -F '[/:]' '{ print $NF }')
    local github_project=${github_project_git%%.git}

    # Again... See README caveats of GitHub's tarball SHA256.
    git archive \
        --prefix=${github_user}-${github_project}-"$ref"/ \
        --format=tar.gz -6 "$ref" |\
            openssl dgst -sha256 |\
                awk '{ print $2 }'
}

main() {
    # Main.

    given awk git openssl

    if [ $# -gt 0 ]; then
        target_ref=$1
    else
        target_ref=HEAD
    fi

    warn-if-dirty-head "$target_ref"

    ref=$(git rev-parse --short $target_ref)

    echo    "ref:    $ref"
    echo -n "sha256: "
    generate-sha256 "$ref"
}

main "$@"
